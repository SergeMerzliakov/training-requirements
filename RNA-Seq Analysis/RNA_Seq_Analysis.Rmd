---
title: "RNA-Seq Analysis"
author: "Serge Merzliakov"
date: "20/06/2021"
output:
  html_document:
    toc: true
    toc_depth: 3
theme: readable
---

```{r setup, include=FALSE, cache=TRUE}

options(width = 120)

BiocManager::install(c("dplyr", "AnnotationDbi", "org.Hs.eg.db", "DESeq2", "tibble", "DT", "BiocParallel","ggplot2"))

library(DESeq2)
library(stringr)
library(fgsea)
library(data.table)
library(ggplot2)


options(scipen=99999)
load('data/SRP034009_rse_gene.Rdata')
rse_gene@colData$condition <- as.factor(c("Control","Control","Control","Salmonella","Salmonella","Salmonella"))
dds <- DESeqDataSet(rse_gene, design = ~ condition)

LOW_EXPRESSION_THRESHOLD <- 10
keep <- rowSums(counts(dds), na.rm = T) >= LOW_EXPRESSION_THRESHOLD
dds <- dds[keep,]
dds_df <- data.frame(counts(dds))

knitr::opts_chunk$set(echo = FALSE)
```

## Overview

An RNA-seq analysis was conducted on a sample RNA counts sample, which comared gene expression in HeLa cells infected with Salmonella Typhimurium. This strain of salmonella causes a gastroenteritis in humans. The  data was obtained from Recount2 (Accession number SRP034009)


### Process 
The analysis was performed using R, using the DEseq2 package for the Differential Gene Expression Analysis (DGE) and the fgsea package for the Gene Set Enrichment Analysis (GSEA).
TODO: experimental design

3 replicates for control HeLa cells
3 replicates for Salmonella Infected HeLa cells

## Conclusion/Results
TODO findings


## Assess The Distribution and Suitability for DESeq2 Analysis 
DESeq2 assumes a negative normal distribution, so the data was checked to assess where this was a valid assumption. The dispersion plot shows that variances exceed the means, so that the use of the DESeq2 algorithm is appropriate.

```{r assessDist,  warning=FALSE, message=FALSE,fig.height=4, fig.width=4, fig.align='center'}
library(ggplot2)
mean_counts <- apply(dds_df[,1:ncol(dds_df)], 1, mean)
variance_counts <- apply(dds_df[,1:ncol(dds_df)], 1, var)

assess_df <- data.frame(mean_counts, variance_counts)


ggplot(assess_df) +
  geom_point((aes(x=mean_counts, y=variance_counts))) +
  scale_y_log10(labels =scales::scientific) +
  scale_x_log10(labels = scales::scientific) +
  xlab("Mean Counts per Gene") +
  ylab("Variance per Gene") +
  annotation_logticks() +
  geom_abline(show.legend=FALSE, aes(intercept = 0, slope = 1, colour='red'))

rm(assess_df, mean_counts, variance_counts)
```

# Principal Component Analysis
``` {r pcaData, warning=FALSE, message=FALSE}
library(DESeq2)

# normalize counts
dds <- estimateSizeFactors(dds)

# log transformation
dds_vst <- vst(dds, blind=T)

pca_data <- t(assay(dds_vst)) ### TODO need t()???

dds_pca <- prcomp(pca_data)

pca_sum <-summary(dds_pca)
print(pca_sum) # todo fix wrap
```
A Principal Component Analysis (PCA) was performed on the data which showed that first two components explain `r round(pca_sum$importance[3,2] * 100, 0)`% of the variance, and the first four components approximately `r round(pca_sum$importance[3,4] * 100, 0)`%.

TODO - more talk re PC1 and PC2
TODO - more talk re PC1 and PC2

``` {r pcaPlotImp, warning=FALSE, message=FALSE, fig.height=6, fig.width=10}
library(gridExtra)

# because PC1 and PC2 account for only 78% of the variance, we plot the top five PCs, with total of ~91% of variance accounted for

varExp <- pca_sum$importance[2,] * 100
# better screen plot variance as % for each PC. Convert to DF for GGPLOT
varDF = data.frame(Component=1:length(1:length(varExp)), varExp=varExp)

# scree plot - home made  by me because its nicer
scree_plot <- ggplot(varDF,aes(x=Component,y=varExp)) +
       geom_col(fill="steelblue") +
       theme_bw() + scale_x_continuous(breaks=seq(0, length(varExp), by = 1)) +
       scale_y_continuous(breaks=seq(0, 100, by = 5)) +
       ylab("% Variance") +
       xlab("Principal Component")

# cumulative variance plot
cumul_prop <- pca_sum$importance[3,] * 100
cumul_df <- data.frame(cumulativeProp = cumul_prop)
cumul_plot <- ggplot(cumul_df, aes(x=c(1:nrow(cumul_df)), y=cumulativeProp)) + geom_point() +
  scale_y_continuous(breaks=seq(0, 100, by = 10)) +
  xlab("Principal Component") +
  ylab("% Cumulative Variance") +
  geom_hline(yintercept = 90, linetype = "dashed",color = "blue", size=0.4) +
  scale_x_continuous(breaks=c(1:nrow(cumul_df))) +
  expand_limits(y = 0)

# PC 1 64%, PC2 12%
# NOTE PlotPCA != prcomp, asDESeq2 first sort the rows by variance,
# select the top NTOP (if by default 500, not all genes) and only then call prcomp
# if ntop = "# genes" then plotPCA gives same value as prcomp

pca_df <- data.frame(condition=rse_gene@colData$condition, dds_pca$x)

palette <- c("Control" = "#ff0000", "Salmonella" = "#0000ff")

pc_1and2 <- ggplot(pca_df) +
  geom_point(aes(x=PC1, y=PC2, color = condition)) +
  xlab(paste0("PC1 (", round(varDF[1,2],1),"%)") ) +
  ylab(paste0("PC2 (", round(varDF[2,2],1),"%")) +
  scale_colour_manual(values = palette)

pc_2and3 <- ggplot(pca_df) +
  geom_point(aes(x=PC2, y=PC3, color = condition)) +
  xlab(paste0("PC2 (", round(varDF[2,2],1),"%)") ) +
  ylab(paste0("PC3 (", round(varDF[3,2],1),"%)")) +
  scale_colour_manual(values = palette)

grid.arrange(scree_plot,cumul_plot,pc_1and2, pc_2and3 ,ncol=2, nrow=2)

```

``` {r generateDES, echo=TRUE, message=TRUE}
library(BiocParallel)

register(MulticoreParam(), default = TRUE)

start <- Sys.time()
print(start)
dds <- DESeq(dds, parallel = TRUE)
duration <- Sys.time() - start
cat("Duration DESeq call is: ")
print(round(duration, 2))

start <- Sys.time()
print(start)
dds_res <- results(dds, parallel = TRUE)
duration <- Sys.time() - start
cat("Duration results call is: ")
print(round(duration, 2))

```

## 
## APPENDIX - Initial Analysis


#### TODO
add process steps here?
source + reproducbility
https://trace.ncbi.nlm.nih.gov/Traces/study/?acc=SRP034009

### Version Details
```{r versionInfo}
sessionInfo()
```



